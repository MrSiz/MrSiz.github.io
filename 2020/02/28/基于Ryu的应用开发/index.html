<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    
    <title>基于Ryu的应用开发 - Philosopher</title>
    <meta charset="utf-8">
    
    <meta name="title" content="基于Ryu的应用开发 - Philosopher">
    <meta name="description" content="">
    <meta property="og:image" content="/favicon.png">
    <meta property="og:image:width" content="200" />
    <meta property="og:image:height" content="200" />
    <link rel="shortcut icon" href="/favicon.png">
    
    <link rel="stylesheet"
        href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/arduino-light.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    
    <link rel="stylesheet" href="/css/style.css">
    <script src="/js/jquery.min.js"></script>
</head>

<body>
    <header class="header">
    <div class="blog-title">
        <a href="/" class="logo">Philosopher</a>
    </div>
    <nav class="navbar">
        <ul class="menu">
            
            
            
            <li class="menu-item">
                
                <a href="/" class="menu-item-link">主页</a>
                
            </li>
            
            
            
            <li class="menu-item">
                
                <a href="/archives" class="menu-item-link">归档</a>
                
            </li>
            
            
            
            <li class="menu-item">
                
                <a href="/about" class="menu-item-link">关于</a>
                
            </li>
            
        </ul>
    </nav>
</header>
    <main class="main">
        <article class="post">
    <div class="post-title">
        <h1 class="title">基于Ryu的应用开发</h2>
    </div>
    <div class="post-content">
        <h3 id="Ryu控制器介绍"><a href="#Ryu控制器介绍" class="headerlink" title="Ryu控制器介绍"></a>Ryu控制器介绍</h3><p>Ryu控制器是日本NTT公司使用Python语言开发的一款开源SDN/OpenFlow控制器。Ryu提供了简单的API接口，开发人员可以方便地编写网络控制程序。Ryu支持管理网络设备的各种协议，如OpenFlow、Netconf和OF-config等协议。此外，Ryu还被整合到了OpenStack的Neutron中。</p>
<h3 id="Ryu的安装与使用"><a href="#Ryu的安装与使用" class="headerlink" title="Ryu的安装与使用"></a>Ryu的安装与使用</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>第一种方式:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">%</span> pip install ryu<br></code></pre></td></tr></table></figure></p>
<p>第二种方式:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">%</span> git clone git://github.com/osrg/ryu.git<br><span class="hljs-meta">%</span> cd ryu; python ./setup.py install<br></code></pre></td></tr></table></figure></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>在安装好Ryu之后，可以通过<code>ryu-manager appname.py</code>的方式运行Ryu应用程序。通常，Ryu的使用是与mininet相结合的，mininet的作用是创建网络拓扑，关于mininet的具体使用方式可以参考官网教程。<br><a id="more"></a></p>
<h3 id="Ryu源码的目录结构"><a href="#Ryu源码的目录结构" class="headerlink" title="Ryu源码的目录结构"></a>Ryu源码的目录结构</h3><ul>
<li><code>app/</code>:该目录下主要包含的是官方提供的应用例子。</li>
<li><code>base/</code>:该目录下只有1个<code>app_manager.py</code>文件，其作用是Ryu应用的管理中心，用于加载Ryu应用程序，接受从App发过来的消息，同时也完成消息的路由。</li>
<li><code>controller/</code>:该目录下主要实现了控制器和交换机之间的互联和事件处理。</li>
<li><code>lib/</code>: 该目录下主要定义了需要使用到的基本数据结构，如dpid、mac和ip等数据结构。此外，如ICMP、DHCP和IGMP等协议也是在该目录下定义的。</li>
<li><code>ofproto/</code>: 该目录下主要定义了与OpenFlow协议相关的数据结构，包含了不同版本OpenFlow协议的定义。</li>
<li><code>topology/</code>: 该目录下定义了switch和host等相关的数据结构。</li>
<li><code>services/</code>：该目录下主要包含了对BGP和vrrp的实现。</li>
</ul>
<h3 id="Ryu中关键变量和API的说明"><a href="#Ryu中关键变量和API的说明" class="headerlink" title="Ryu中关键变量和API的说明"></a>Ryu中关键变量和API的说明</h3><ul>
<li><code>buffer_id</code>:该变量用于标记缓存在交换机中的数据报文id，通过bufferid将报文缓存在交换机中，减小性能开销。</li>
<li><code>set_ev_cls()</code>：该装饰器函数主要用来监听相应的事件，在具体实现中常常写作:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">packetin_handler</span><span class="hljs-params">(self, ev)</span>:</span><br>    <span class="hljs-comment"># 处理函数具体实现代码</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<p><code>set_ev_cls()</code>函数的第一个参数表示的是所监听的事件名，第二个参数表示所处的阶段。在上面的代码中，当Ryu和交换机握手过程（即hello, features request/reply, Set Config等）结束后(即处于<code>MAIN_DISPATCHER</code>阶段)，当收到<code>PacketIn</code>消息才会调用<code>packet_in_handler</code>处理函数。</p>
<ul>
<li><code>OFPFlowMod类</code>,该类主要是对<code>FlowMod</code>消息的封装，由控制器下发到交换机上,对流表规则进行相应的修改。</li>
<li><code>DataPath类</code>,该类主要就是交换机的抽象描述，其中的<code>id</code>变量即唯一指定了数据层中的一个交换机。</li>
<li><code>OFPInstructionActions类</code>，该类主要是流表动作的抽象，开发者构造具体的流表动作，如转发到其他所有端口。该动作被包含在FlowMod消息中。</li>
</ul>
<h3 id="编写基于IP转发的应用"><a href="#编写基于IP转发的应用" class="headerlink" title="编写基于IP转发的应用"></a>编写基于IP转发的应用</h3><p>Ryu的代码采用面向对象的风格进行编写的，在开发我们自己的应用时，只需要导入相关的包，然后继承<code>app_manager.RyuApp类</code>,即:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ryu.base <span class="hljs-keyword">import</span> app_manager<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SIMPE_IP_FORWARD</span><span class="hljs-params">(app_manager.RyuApp)</span>:</span><br>    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, *args, **kwargs)</span>:</span><br>        super(SIMPE_IP_FORWARD, self).__init__(*args, **kwargs)<br></code></pre></td></tr></table></figure></p>
<p>通过这种方式就完成了APP的创建，然后我们需要添加默认规则到交换机上，因为交换机上的流表最开始是没有流规则的，而SDN交换机对数据包的处理全是基于流表规则进行的，如果没有流表规则，交换机则不知道该如何处理数据包，所以我们需要主动安装默认规则到交换机上，让交换机将不匹配的数据包上传到控制器上，交由控制器分析处理，代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">""" 控制器与交换机建立连接时，下发默认规则到交换机上，默认将不匹配的流上传到控制器处理"""</span><br><br><span class="hljs-meta">@set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">switch_features_handler</span><span class="hljs-params">(self, ev)</span>:</span><br>    datapath = ev.msg.datapath<br>    ofproto = datapath.ofproto<br>    parser = datapath.ofproto_parser<br>    match = parser.OFPMatch()<br>    actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER)]<br>    self.add_flow(datapath, <span class="hljs-number">0</span>, match, actions)<br></code></pre></td></tr></table></figure></p>
<p>该<code>switch_features_handler()</code>函数作为应用的成员函数而存在，其中装饰器函数<code>set_ev_cls()</code>表示的是监听控制器与交换机建立时互发的消息，当交换机将自己的相关信息告诉给控制器的时候，将触发该函数，注意这个信息不是通过流规则匹配而上传到控制器的，而是在建立连接时产生的，所以此时交换机上是不存在流规则的。<code>parser.OFPActionOutput(ofproto.OFPP_CONTROLLER)</code>表示将匹配的数据包上传到控制器。</p>
<p>当交换机上有了默认的流规则之后，遇到新流时，交换机将会产生<code>PacketIn</code>消息到控制器上，所以控制器必须对PacketIn消息进行处理，由此，我们需要添加处理函数如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">""" 控制器处理收到的PacketIn消息"""</span><br><span class="hljs-meta">@set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">packetin_handler</span><span class="hljs-params">(self, ev)</span>:</span><br><br>    <span class="hljs-keyword">if</span> eth.ethertype == ether_types.ETH_TYPE_ARP:<br>        arp_pkt = pkt.get_protocol(arp.arp)<br>        dpid = datapath.id<br>        src_mac = arp_pkt.src_mac<br>        dst_mac = arp_pkt.dst_mac<br>        temp = (dpid, src_mac, arp_pkt.dst_ip)<br>    <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.flag[temp]:<br>            self.flag[temp] = <span class="hljs-keyword">True</span><br>            self.arp_port[temp] = in_port<br>        <span class="hljs-keyword">elif</span> self.flag[temp] <span class="hljs-keyword">and</span> self.arp_port[temp] != in_port:<br>            <span class="hljs-string">"""记录了的消息来自于同一交换机的不同端口，则不处理，以此避免网络风暴"""</span><br>            <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure></p>
<p>上面的代码只是处理函数的部分函数，该部分代码的作用是通过对相应的端口进行记录，避免产生网络风暴。因为网络拓扑的结构可能是环形的，所以需要对数据包进行处理，避免重复转发，我们利用ARP报文，提取了相关交换机的MAC地址，通过对MAC地址和端口进行记录和对比，避免对报文的重复转发。在此之后，我们还需要处理带有IP地址的数据包，从而实现基于IP的地址转发，关键点即是下发基于IP地址匹配的流规则到交换机上，流规则匹配到了对应的数据包，则按照指令进行数据包转发，关键代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">"""<br> 1. 下发流规则到交换机<br> 2. 将数据包转发出去<br>"""</span><br>match = ofp_parser.OFPMatch(eth_type=<span class="hljs-number">0x800</span>, in_port=in_port, ipv4_src=ip_pkt.src, ipv4_dst=ip_pkt.dst)<br>actions = [ofp_parser.OFPActionOutput(out_port)]<br>self.add_flow(datapath, <span class="hljs-number">10</span>, match, actions)<br><br>data = <span class="hljs-keyword">None</span><br><span class="hljs-keyword">if</span> msg.buffer_id == ofproto.OFP_NO_BUFFER:<br>    data = msg.data<br>out = ofp_parser.OFPPacketOut(datapath=datapath, buffer_id=msg.buffer_id,<br>                          in_port=in_port, actions=actions, data=data)<br>datapath.send_msg(out)<br></code></pre></td></tr></table></figure></p>
<p>该部分代码在<code>packetin_handler()</code>对IP报文进行相关处理，主要是根据相关的记录，获取到出端口，然后下发匹配规则到交换机上，再转发出去。其中的匹配规则是通过<code>OFPMatch()</code>类所构造的，在其中主要就是指定ip地址。</p>
<p>以上就是实现一个基于IP转发的Ryu应用的关键点，更多的细节可以参考:<a href="https://github.com/MrSiz/SDN/blob/master/ryu/simple_ip_forward.py。" target="_blank" rel="noopener">https://github.com/MrSiz/SDN/blob/master/ryu/simple_ip_forward.py。</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要对Ryu控制器进行了简单的介绍，并对实际开发一个Ryu应用进行了重点说明。在具体的实践过程中，大家可以在阅读Ryu源码的同时进行实际应用的开发，基于Python的简单以及良好的API接口，开发一个Ryu应用并非难事。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p>[1] <a href="https://www.sdnlab.com/11688.html" target="_blank" rel="noopener">https://www.sdnlab.com/11688.html</a><br>[2] <a href="https://www.cnblogs.com/fjlinww/p/11904076.html" target="_blank" rel="noopener">https://www.cnblogs.com/fjlinww/p/11904076.html</a><br>[3] <a href="https://www.cnblogs.com/zxqstrong/p/4789105.html" target="_blank" rel="noopener">https://www.cnblogs.com/zxqstrong/p/4789105.html</a><br>[4] <a href="https://www.cnblogs.com/fjlinww/p/11904076.html" target="_blank" rel="noopener">https://www.cnblogs.com/fjlinww/p/11904076.html</a></p>

    </div>
    <div class="post-meta">
        <span class="post-time">2020/02/28</span>
    </div>
</article>

<div class="prev_next">
    <nav id="prev_next">

<div class="prev">
    
</div>
<div class="next">
    
    <p>下一篇</p>
    <a href="/2018/06/20/linux下编译运行bochs/"><div class="article-nav-title">linux下编译运行bochs</div></a>
    
</div>

</nav>
</div>

<div class="post-comment">
    



</div>
    </main>
</body>

</html>