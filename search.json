[{"title":"基于Ryu的应用开发","url":"http://mrsiz.github.io/2020/02/28/基于Ryu的应用开发/","content":"<h3 id=\"Ryu控制器介绍\"><a href=\"#Ryu控制器介绍\" class=\"headerlink\" title=\"Ryu控制器介绍\"></a>Ryu控制器介绍</h3><p>Ryu控制器是日本NTT公司使用Python语言开发的一款开源SDN/OpenFlow控制器。Ryu提供了简单的API接口，开发人员可以方便地编写网络控制程序。Ryu支持管理网络设备的各种协议，如OpenFlow、Netconf和OF-config等协议。此外，Ryu还被整合到了OpenStack的Neutron中。</p>\n<h3 id=\"Ryu的安装与使用\"><a href=\"#Ryu的安装与使用\" class=\"headerlink\" title=\"Ryu的安装与使用\"></a>Ryu的安装与使用</h3><h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>第一种方式:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">%</span> pip install ryu<br></code></pre></td></tr></table></figure></p>\n<p>第二种方式:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">%</span> git clone git://github.com/osrg/ryu.git<br><span class=\"hljs-meta\">%</span> cd ryu; python ./setup.py install<br></code></pre></td></tr></table></figure></p>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>在安装好Ryu之后，可以通过<code>ryu-manager appname.py</code>的方式运行Ryu应用程序。通常，Ryu的使用是与mininet相结合的，mininet的作用是创建网络拓扑，关于mininet的具体使用方式可以参考官网教程。<br><a id=\"more\"></a></p>\n<h3 id=\"Ryu源码的目录结构\"><a href=\"#Ryu源码的目录结构\" class=\"headerlink\" title=\"Ryu源码的目录结构\"></a>Ryu源码的目录结构</h3><ul>\n<li><code>app/</code>:该目录下主要包含的是官方提供的应用例子。</li>\n<li><code>base/</code>:该目录下只有1个<code>app_manager.py</code>文件，其作用是Ryu应用的管理中心，用于加载Ryu应用程序，接受从App发过来的消息，同时也完成消息的路由。</li>\n<li><code>controller/</code>:该目录下主要实现了控制器和交换机之间的互联和事件处理。</li>\n<li><code>lib/</code>: 该目录下主要定义了需要使用到的基本数据结构，如dpid、mac和ip等数据结构。此外，如ICMP、DHCP和IGMP等协议也是在该目录下定义的。</li>\n<li><code>ofproto/</code>: 该目录下主要定义了与OpenFlow协议相关的数据结构，包含了不同版本OpenFlow协议的定义。</li>\n<li><code>topology/</code>: 该目录下定义了switch和host等相关的数据结构。</li>\n<li><code>services/</code>：该目录下主要包含了对BGP和vrrp的实现。</li>\n</ul>\n<h3 id=\"Ryu中关键变量和API的说明\"><a href=\"#Ryu中关键变量和API的说明\" class=\"headerlink\" title=\"Ryu中关键变量和API的说明\"></a>Ryu中关键变量和API的说明</h3><ul>\n<li><code>buffer_id</code>:该变量用于标记缓存在交换机中的数据报文id，通过bufferid将报文缓存在交换机中，减小性能开销。</li>\n<li><code>set_ev_cls()</code>：该装饰器函数主要用来监听相应的事件，在具体实现中常常写作:<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">@set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">packetin_handler</span><span class=\"hljs-params\">(self, ev)</span>:</span><br>    <span class=\"hljs-comment\"># 处理函数具体实现代码</span><br>    <span class=\"hljs-keyword\">pass</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><code>set_ev_cls()</code>函数的第一个参数表示的是所监听的事件名，第二个参数表示所处的阶段。在上面的代码中，当Ryu和交换机握手过程（即hello, features request/reply, Set Config等）结束后(即处于<code>MAIN_DISPATCHER</code>阶段)，当收到<code>PacketIn</code>消息才会调用<code>packet_in_handler</code>处理函数。</p>\n<ul>\n<li><code>OFPFlowMod类</code>,该类主要是对<code>FlowMod</code>消息的封装，由控制器下发到交换机上,对流表规则进行相应的修改。</li>\n<li><code>DataPath类</code>,该类主要就是交换机的抽象描述，其中的<code>id</code>变量即唯一指定了数据层中的一个交换机。</li>\n<li><code>OFPInstructionActions类</code>，该类主要是流表动作的抽象，开发者构造具体的流表动作，如转发到其他所有端口。该动作被包含在FlowMod消息中。</li>\n</ul>\n<h3 id=\"编写基于IP转发的应用\"><a href=\"#编写基于IP转发的应用\" class=\"headerlink\" title=\"编写基于IP转发的应用\"></a>编写基于IP转发的应用</h3><p>Ryu的代码采用面向对象的风格进行编写的，在开发我们自己的应用时，只需要导入相关的包，然后继承<code>app_manager.RyuApp类</code>,即:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> ryu.base <span class=\"hljs-keyword\">import</span> app_manager<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SIMPE_IP_FORWARD</span><span class=\"hljs-params\">(app_manager.RyuApp)</span>:</span><br>    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span><span class=\"hljs-params\">(self, *args, **kwargs)</span>:</span><br>        super(SIMPE_IP_FORWARD, self).__init__(*args, **kwargs)<br></code></pre></td></tr></table></figure></p>\n<p>通过这种方式就完成了APP的创建，然后我们需要添加默认规则到交换机上，因为交换机上的流表最开始是没有流规则的，而SDN交换机对数据包的处理全是基于流表规则进行的，如果没有流表规则，交换机则不知道该如何处理数据包，所以我们需要主动安装默认规则到交换机上，让交换机将不匹配的数据包上传到控制器上，交由控制器分析处理，代码如下:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-string\">\"\"\" 控制器与交换机建立连接时，下发默认规则到交换机上，默认将不匹配的流上传到控制器处理\"\"\"</span><br><br><span class=\"hljs-meta\">@set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">switch_features_handler</span><span class=\"hljs-params\">(self, ev)</span>:</span><br>    datapath = ev.msg.datapath<br>    ofproto = datapath.ofproto<br>    parser = datapath.ofproto_parser<br>    match = parser.OFPMatch()<br>    actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER)]<br>    self.add_flow(datapath, <span class=\"hljs-number\">0</span>, match, actions)<br></code></pre></td></tr></table></figure></p>\n<p>该<code>switch_features_handler()</code>函数作为应用的成员函数而存在，其中装饰器函数<code>set_ev_cls()</code>表示的是监听控制器与交换机建立时互发的消息，当交换机将自己的相关信息告诉给控制器的时候，将触发该函数，注意这个信息不是通过流规则匹配而上传到控制器的，而是在建立连接时产生的，所以此时交换机上是不存在流规则的。<code>parser.OFPActionOutput(ofproto.OFPP_CONTROLLER)</code>表示将匹配的数据包上传到控制器。</p>\n<p>当交换机上有了默认的流规则之后，遇到新流时，交换机将会产生<code>PacketIn</code>消息到控制器上，所以控制器必须对PacketIn消息进行处理，由此，我们需要添加处理函数如下:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-string\">\"\"\" 控制器处理收到的PacketIn消息\"\"\"</span><br><span class=\"hljs-meta\">@set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">packetin_handler</span><span class=\"hljs-params\">(self, ev)</span>:</span><br><br>    <span class=\"hljs-keyword\">if</span> eth.ethertype == ether_types.ETH_TYPE_ARP:<br>        arp_pkt = pkt.get_protocol(arp.arp)<br>        dpid = datapath.id<br>        src_mac = arp_pkt.src_mac<br>        dst_mac = arp_pkt.dst_mac<br>        temp = (dpid, src_mac, arp_pkt.dst_ip)<br>    <br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> self.flag[temp]:<br>            self.flag[temp] = <span class=\"hljs-keyword\">True</span><br>            self.arp_port[temp] = in_port<br>        <span class=\"hljs-keyword\">elif</span> self.flag[temp] <span class=\"hljs-keyword\">and</span> self.arp_port[temp] != in_port:<br>            <span class=\"hljs-string\">\"\"\"记录了的消息来自于同一交换机的不同端口，则不处理，以此避免网络风暴\"\"\"</span><br>            <span class=\"hljs-keyword\">return</span><br></code></pre></td></tr></table></figure></p>\n<p>上面的代码只是处理函数的部分函数，该部分代码的作用是通过对相应的端口进行记录，避免产生网络风暴。因为网络拓扑的结构可能是环形的，所以需要对数据包进行处理，避免重复转发，我们利用ARP报文，提取了相关交换机的MAC地址，通过对MAC地址和端口进行记录和对比，避免对报文的重复转发。在此之后，我们还需要处理带有IP地址的数据包，从而实现基于IP的地址转发，关键点即是下发基于IP地址匹配的流规则到交换机上，流规则匹配到了对应的数据包，则按照指令进行数据包转发，关键代码如下:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-string\">\"\"\"<br> 1. 下发流规则到交换机<br> 2. 将数据包转发出去<br>\"\"\"</span><br>match = ofp_parser.OFPMatch(eth_type=<span class=\"hljs-number\">0x800</span>, in_port=in_port, ipv4_src=ip_pkt.src, ipv4_dst=ip_pkt.dst)<br>actions = [ofp_parser.OFPActionOutput(out_port)]<br>self.add_flow(datapath, <span class=\"hljs-number\">10</span>, match, actions)<br><br>data = <span class=\"hljs-keyword\">None</span><br><span class=\"hljs-keyword\">if</span> msg.buffer_id == ofproto.OFP_NO_BUFFER:<br>    data = msg.data<br>out = ofp_parser.OFPPacketOut(datapath=datapath, buffer_id=msg.buffer_id,<br>                          in_port=in_port, actions=actions, data=data)<br>datapath.send_msg(out)<br></code></pre></td></tr></table></figure></p>\n<p>该部分代码在<code>packetin_handler()</code>对IP报文进行相关处理，主要是根据相关的记录，获取到出端口，然后下发匹配规则到交换机上，再转发出去。其中的匹配规则是通过<code>OFPMatch()</code>类所构造的，在其中主要就是指定ip地址。</p>\n<p>以上就是实现一个基于IP转发的Ryu应用的关键点，更多的细节可以参考:<a href=\"https://github.com/MrSiz/SDN/blob/master/ryu/simple_ip_forward.py。\" target=\"_blank\" rel=\"noopener\">https://github.com/MrSiz/SDN/blob/master/ryu/simple_ip_forward.py。</a></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文主要对Ryu控制器进行了简单的介绍，并对实际开发一个Ryu应用进行了重点说明。在具体的实践过程中，大家可以在阅读Ryu源码的同时进行实际应用的开发，基于Python的简单以及良好的API接口，开发一个Ryu应用并非难事。</p>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p>[1] <a href=\"https://www.sdnlab.com/11688.html\" target=\"_blank\" rel=\"noopener\">https://www.sdnlab.com/11688.html</a><br>[2] <a href=\"https://www.cnblogs.com/fjlinww/p/11904076.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/fjlinww/p/11904076.html</a><br>[3] <a href=\"https://www.cnblogs.com/zxqstrong/p/4789105.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zxqstrong/p/4789105.html</a><br>[4] <a href=\"https://www.cnblogs.com/fjlinww/p/11904076.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/fjlinww/p/11904076.html</a></p>\n","categories":[],"tags":["SDN","Ryu"]},{"title":"linux下编译运行bochs","url":"http://mrsiz.github.io/2018/06/20/linux下编译运行bochs/","content":"<p>记录一下在安装和配置运行bochs的过程中遇见的问题，以及解决办法。</p>\n<h2 id=\"安装环境\"><a href=\"#安装环境\" class=\"headerlink\" title=\"安装环境\"></a>安装环境</h2><ul>\n<li>ubuntu 16.04</li>\n<li>bochs 2.6.9</li>\n</ul>\n<h2 id=\"问题及解决办法\"><a href=\"#问题及解决办法\" class=\"headerlink\" title=\"问题及解决办法\"></a>问题及解决办法</h2><p>1.<code>gui/libgui.a(x.o): undefined reference to symbol &#39;XSetForeground&#39;</code><br>解决：控制台下输入<code>sudo apt-get install xorg-dev</code></p>\n<p>2.<code>X11/Xlib.h: No such file or directory</code><br>解决：控制台下输入<code>sudo apt-get install libx11-dev</code><br><a id=\"more\"></a><br>3.<code>&gt;&gt;PANIC&lt;&lt; bochsrc.txt:13: keyboard directive malformed.</code><br>解决：在配置文件 <strong>bochsrc.txt</strong> 中，设置<code>keyboard: keymap=/home/mrsiz/bochs/share/bochs/keymaps/x11-pc-de.map</code>   </p>\n<p>4.<code>&gt;&gt;PANIC&lt;&lt; bochsrc.txt:17: Bochs is not compiled with gdbstub support</code><br>解决：在最开始用<code>.configure</code>生成MakeFile配置文件的时候，如果没有添加gdb远程调试那个选项，但是又在配置文件中开启了远程调试这个功能，就会报这个错，直接注释掉配置文件中的<code>gdbstub</code>那一行</p>\n<p>5.连接时出现了没找到引用的情况<code>undefined reference</code><br>解决：在MakeFile文件中，修改<code>LIBS = -lX11 -lXtst  -lpthread</code>,一般只加这几个需要链接的库就行</p>\n<p>6.出现权限问题，比如不能写<br>解决：这个问题的出现是因为bochs这个文件夹是root级别的，当用普通用户权限运行./bochs的时候，因为权限不够就会造成这个问题，所以只要加上sudo就行。  </p>\n<p>7.启动盘的创建，在运行bochs的时候，需要有启动盘<br>解决：执行<code>./bximage</code>,差不多可以一路回车，也可以按照提示做简单的自定义修改</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>因为上面出现的问题都是我在解决之后，回过头来写的，所以可能在配置bochs过程中还有其他问题，因为忘记了，所以没有记录下来。在看了网上的相关配置之后，差不多是copy加上略微修改得到一份配置文件 <strong>bochsrc.txt</strong>,放在/bin/目录下，运行./bochs的时候会直接读这个配置文件。内容如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">megs: 32<br><br>romimage: file=/home/mrsiz/bochs/share/bochs/BIOS-bochs-latest<br>vgaromimage: file=/home/mrsiz/bochs/share/bochs/VGABIOS-lgpl-latest<br><br>boot: disk <br><br>log: bochs.out<br><br>mouse: enabled=0<br>keyboard: keymap=/home/mrsiz/bochs/share/bochs/keymaps/x11-pc-de.map<br><br>ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14 <br><br>#gdbstub: enabled=0, port=1234, text_base=0, data_base=0, bass_base=0 <br>ata0-master: type=disk, path=&quot;hd60M.img&quot;, mode=flat<br></code></pre></td></tr></table></figure></p>\n<p>因为重点是搭建好一个可编译运行linux内核的环境，所以对于在使用bochs中所遇到的问题，采取的方针是：能正常运行就好。</p>\n","categories":[],"tags":["环境配置"]},{"title":"类的内存布局","url":"http://mrsiz.github.io/2018/04/28/类的内存布局/","content":"<p>探讨C++中的类的内存布局，对于这个问题，网上可以搜索到很多的文章了。但是自己还是打算测试一下，权当是检验真理。</p>\n<h3 id=\"测试环境\"><a href=\"#测试环境\" class=\"headerlink\" title=\"测试环境\"></a>测试环境</h3><ul>\n<li>VS2017 (Debug模式下x86)</li>\n</ul>\n<p>本文主要是对多继承的测试，首先看一下代码.<br><a id=\"more\"></a><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">funcA</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-keyword\">int</span> a;<br>&#125;;<br><br><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span> :</span> <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> A &#123;<br><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">funcA</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">funcB</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-keyword\">int</span> b;<br>&#125;;<br><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">C</span> :</span> <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> A &#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">funcA</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">funcC</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-keyword\">int</span> c;<br>&#125;;<br><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">D</span> :</span> <span class=\"hljs-keyword\">public</span> B, <span class=\"hljs-keyword\">public</span> C &#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">funcA</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">funcD</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-keyword\">int</span> d;<br>&#125;;<br><br><span class=\"hljs-comment\">/*<br>    A<br>   / \\<br>  B   C<br>   \\ /<br>    D<br>类的继承体系如上，虚继承。<br>*/</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span><br></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>\n<p>在VS中添加编译选项<code>/d1 reportAllClassLayout</code>得到如下的结果：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">class A\tsize(8):<br>\t+---<br> 0\t| &#123;vfptr&#125;<br> 4\t| a<br>\t+---<br><br>A::$vftable@:<br>\t| &amp;A_meta<br>\t|  0<br> 0\t| &amp;A::funcA<br><br>A::funcA this adjustor: 0<br><br>class B\tsize(20):<br>\t+---<br> 0\t| &#123;vfptr&#125;<br> 4\t| &#123;vbptr&#125;<br> 8\t| b<br>\t+---<br>\t+--- (virtual base A)<br>12\t| &#123;vfptr&#125;<br>16\t| a<br>\t+---<br><br>B::$vftable@B@:<br>\t| &amp;B_meta<br>\t|  0<br> 0\t| &amp;B::funcB<br><br>B::$vbtable@:<br> 0\t| -4<br> 1\t| 8 (Bd(B+4)A)<br><br>B::$vftable@A@:<br>\t| -12<br> 0\t| &amp;B::funcA<br><br>B::funcA this adjustor: 12<br>B::funcB this adjustor: 0<br>vbi:\t   class  offset o.vbptr  o.vbte fVtorDisp<br>               A      12       4       4 0<br><br>class C\tsize(20):<br>\t+---<br> 0\t| &#123;vfptr&#125;<br> 4\t| &#123;vbptr&#125;<br> 8\t| c<br>\t+---<br>\t+--- (virtual base A)<br>12\t| &#123;vfptr&#125;<br>16\t| a<br>\t+---<br><br>C::$vftable@C@:<br>\t| &amp;C_meta<br>\t|  0<br> 0\t| &amp;C::funcC<br><br>C::$vbtable@:<br> 0\t| -4<br> 1\t| 8 (Cd(C+4)A)<br><br>C::$vftable@A@:<br>\t| -12<br> 0\t| &amp;C::funcA<br><br>C::funcA this adjustor: 12<br>C::funcC this adjustor: 0<br>vbi:\t   class  offset o.vbptr  o.vbte fVtorDisp<br>               A      12       4       4 0<br><br>class D\tsize(36):<br>\t+---<br> 0\t| +--- (base class B)<br> 0\t| | &#123;vfptr&#125;<br> 4\t| | &#123;vbptr&#125;<br> 8\t| | b<br>\t| +---<br>12\t| +--- (base class C)<br>12\t| | &#123;vfptr&#125;<br>16\t| | &#123;vbptr&#125;<br>20\t| | c<br>\t| +---<br>24\t| d<br>\t+---<br>\t+--- (virtual base A)<br>28\t| &#123;vfptr&#125;<br>32\t| a<br>\t+---<br><br>D::$vftable@B@:<br>\t| &amp;D_meta<br>\t|  0<br> 0\t| &amp;B::funcB<br> 1\t| &amp;D::funcD<br><br>D::$vftable@C@:<br>\t| -12<br> 0\t| &amp;C::funcC<br><br>D::$vbtable@B@:<br> 0\t| -4<br> 1\t| 24 (Dd(B+4)A)<br><br>D::$vbtable@C@:<br> 0\t| -4<br> 1\t| 12 (Dd(C+4)A)<br><br>D::$vftable@A@:<br>\t| -28<br> 0\t| &amp;D::funcA<br><br>D::funcA this adjustor: 28<br>D::funcD this adjustor: 0<br>vbi:\t   class  offset o.vbptr  o.vbte fVtorDisp<br>               A      28       4       4 0<br></code></pre></td></tr></table></figure></p>\n<p>由上可知:</p>\n<ol>\n<li>存在虚函数的类中都会有vfptr(指向虚函数表)</li>\n<li>从虚基类继承的时候，虚基类排在最后面</li>\n<li>虚继承利用到了vbptr,若不是虚继承，则会重复包含父类成员</li>\n</ol>\n<h3 id=\"其它问题\"><a href=\"#其它问题\" class=\"headerlink\" title=\"其它问题\"></a>其它问题</h3><h5 id=\"1-为什么类B和C有自己的虚函数的时候，会增加一个vfptr-而D有自己的虚函数的时候不会再增加一个vfptr\"><a href=\"#1-为什么类B和C有自己的虚函数的时候，会增加一个vfptr-而D有自己的虚函数的时候不会再增加一个vfptr\" class=\"headerlink\" title=\"1. 为什么类B和C有自己的虚函数的时候，会增加一个vfptr,而D有自己的虚函数的时候不会再增加一个vfptr?\"></a>1. 为什么类B和C有自己的虚函数的时候，会增加一个vfptr,而D有自己的虚函数的时候不会再增加一个vfptr?</h5><p>个人理解是因为类会把自己的虚函数加入到第一个vfptr指向的虚函数表中去，因为类B第一个成员不是vfptr,所以编译器自动加了一个vfptr….纯属个人理解。</p>\n<h4 id=\"2-如何直接调用一个虚函数\"><a href=\"#2-如何直接调用一个虚函数\" class=\"headerlink\" title=\"2. 如何直接调用一个虚函数\"></a>2. 如何直接调用一个虚函数</h4><p>一个简单示例:<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;cstdlib&gt;</span></span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">func1</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">\"hello Test\\n\"</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">func2</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span><br></span>&#123;<br>\tTest a;<br>\t<span class=\"hljs-comment\">//通过类型转换获得虚表的地址</span><br>\t<span class=\"hljs-keyword\">auto</span> vtable = (<span class=\"hljs-keyword\">intptr_t</span>*)(*(<span class=\"hljs-keyword\">intptr_t</span>*)(&amp;a));<br><br>\t<span class=\"hljs-keyword\">auto</span> func1 = (<span class=\"hljs-keyword\">void</span>(*)())vtable[<span class=\"hljs-number\">0</span>];<br>\t<span class=\"hljs-keyword\">auto</span> func2 = (<span class=\"hljs-keyword\">int</span>(*)())vtable[<span class=\"hljs-number\">1</span>];<br>\tfunc1();<br>\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">cout</span> &lt;&lt; func2() &lt;&lt; <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">endl</span>;<br><br>\tsystem(<span class=\"hljs-string\">\"pause\"</span>);<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>\n<p>通过直接获得类中的vfptr中的地址，然后再通过类型的转换，获得虚函数表的地址，然后再从虚函数表中获得函数地址，最后调用即可。进行类型转换的原因是因为需要对指针解引用，而指针所指向的类型影响到了解引用时的内存大小，所以需要进行合理地类型转换，否则会出错的。</p>\n","categories":[],"tags":["c++"]},{"title":"利用python登录服务器并下载文件","url":"http://mrsiz.github.io/2018/04/13/利用python登录服务器并下载文件/","content":"<p>最近在写一个程序，需要访问服务器上的数据。最开始的时候我想的是，服务器与主机上分别放两个程序，然后通信，做数据的传输。但是感觉太麻烦了，为了简单点，然后就在网上查了相关的资料，想出了一个解决方案：主机上利用一个脚本访问服务器，通过ssh登录,然后直接去把服务器上的数据下载下来。</p>\n<h3 id=\"需要解决的问题\"><a href=\"#需要解决的问题\" class=\"headerlink\" title=\"需要解决的问题:\"></a>需要解决的问题:</h3><ol>\n<li>如何在脚本程序中登录到服务器中</li>\n<li>如何通过脚本在服务器上直接执行命令(非重点= =)</li>\n<li>如何对文件的状态进行判断，只下载最新的数据到本地</li>\n<li>文件的传输</li>\n</ol>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"开发环境说明\"><a href=\"#开发环境说明\" class=\"headerlink\" title=\"开发环境说明\"></a>开发环境说明</h3><ul>\n<li>ubuntu 16.04.1 x86_64 </li>\n<li>python 2.7.2</li>\n</ul>\n<hr>\n<h3 id=\"利用Paramiko进行ssh登录和下载\"><a href=\"#利用Paramiko进行ssh登录和下载\" class=\"headerlink\" title=\"利用Paramiko进行ssh登录和下载\"></a>利用Paramiko进行ssh登录和下载</h3><h4 id=\"paramiko安装\"><a href=\"#paramiko安装\" class=\"headerlink\" title=\"paramiko安装\"></a>paramiko安装</h4><p>具体可以访问<a href=\"http://www.paramiko.org/\" target=\"_blank\" rel=\"noopener\">官网</a>。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span> paramiko 依赖于cryptography<br> pip install cryptography<br> pip install paramiko<br></code></pre></td></tr></table></figure></p>\n<h4 id=\"登录服务器\"><a href=\"#登录服务器\" class=\"headerlink\" title=\"登录服务器\"></a>登录服务器</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> paramiko <br><br>client = paramiko.SSHClient()<br>client.set_missing_host_key_policy(paramiko.AutoAddPolicy())<br><span class=\"hljs-comment\">#自己设置服务器的相关值</span><br>client.connect(hostname=<span class=\"hljs-string\">'xxx'</span>,port= <span class=\"hljs-number\">22</span>, username=<span class=\"hljs-string\">'xxx'</span>, password=<span class=\"hljs-string\">'xxx'</span>)<br><br>stdin, stdout, stderr = client.exec_command(<span class=\"hljs-string\">'ls'</span>)<br><br>result = stdout.read()<br><span class=\"hljs-comment\">#打印result，用来测试是否连接成功</span><br><span class=\"hljs-keyword\">print</span> result<br>client.close()<br></code></pre></td></tr></table></figure>\n<p>这些函数的使用在官方API有说明，当然也可以直接搜索到。</p>\n<h3 id=\"下载文件\"><a href=\"#下载文件\" class=\"headerlink\" title=\"下载文件\"></a>下载文件</h3><p>官网API中指出，利用SFTP的<code>get()</code>方法可以进行下载。在前面的代码中，使用了<code>exec_command()</code>在服务器上执行shell命令，理论上，直接执行命令把输出存储在本地应该也是可以的。但我还是采用的第一种方式，因为简单。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\">#coding:UTF-8</span><br><span class=\"hljs-keyword\">import</span> paramiko <br><br><span class=\"hljs-comment\">#ssh登录服务器</span><br>client = paramiko.SSHClient()<br>client.set_missing_host_key_policy(paramiko.AutoAddPolicy())<br><br><span class=\"hljs-comment\">#相关参数设置</span><br>client.connect(hostname=<span class=\"hljs-string\">'xxxxx'</span>,port= <span class=\"hljs-number\">22</span>, username=<span class=\"hljs-string\">'xxxx'</span>, password=<span class=\"hljs-string\">'xxxxx'</span>)<br><br><span class=\"hljs-comment\">#服务器上的文件路径</span><br>log_server = <span class=\"hljs-string\">'/usr/local/nginx/logs/access.log'</span><br><br><span class=\"hljs-comment\">#本地存储路径</span><br>log_client = <span class=\"hljs-string\">'/home/mrsiz/test.log'</span><br><br><span class=\"hljs-comment\">#服务器上执行的命令 </span><br>count_line = <span class=\"hljs-string\">'wc -l '</span> + log_server<br><br>stdin, stdout, stderr = client.exec_command(count_line)<br>result = stdout.read()<br><span class=\"hljs-comment\">#本地打印结果</span><br><span class=\"hljs-keyword\">print</span> result<br><br><span class=\"hljs-comment\">#从SSHClient中获得一个transport，因为sftp依赖于这个transport</span><br>trans  = client.get_transport()<br>sftp= paramiko.SFTPClient.from_transport(trans)<br><br><span class=\"hljs-comment\">#下载文件</span><br>sftp.get(log_server, log_client)<br><br>client.close()<br></code></pre></td></tr></table></figure></p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>我想，如果要从服务器上获得文件，最暴力的方式就是直接人工登录到服务器，然后直接把数据拷贝到主机上就行了。但是为了更加简单，于是在网上找了python的这个库，直接用封装好的方法完成了文件的下载。到这里，其实已经解决了我最开始提到的1,2,4这三个问题，还有一个问题没有解决。对于这个问题，我在网上搜了相关资料和看了下paramiko提供的相关方法之后，采取了一个特别简单但又有点蠢的方法：直接在一定间隔时间段后重新下载文件。。。。。。。</p>\n","categories":[],"tags":["python","ssh"]},{"title":"about","url":"http://mrsiz.github.io/about/index.html","content":"<p>二十有余，无酒有梦；生于巴渝，今在江城</p>\n<h4 id=\"邮箱\"><a href=\"#邮箱\" class=\"headerlink\" title=\"邮箱\"></a>邮箱</h4><p><a href=\"mailto:zhmssl@foxmail.com\" target=\"_blank\" rel=\"noopener\">zhmssl@foxmail.com</a></p>\n","categories":[],"tags":[]},{"title":"tag","url":"http://mrsiz.github.io/category/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://mrsiz.github.io/tag/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://mrsiz.github.io/search/index.html","content":"","categories":[],"tags":[]}]